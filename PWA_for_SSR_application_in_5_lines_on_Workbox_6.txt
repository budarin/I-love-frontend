PWA for SSR application in 5 lines on Workbox 6.

In the article I want to touch on the following questions:

- what is PWA why
- does our application need a service worker
- why did we decide to rewrite the service worker to Workbox 6
- cache integrity issue and some features of Workbox 6 when updating versions

PWA (progressive web application) is a technology in web development that visually and functionally transforms a website into an application.

Perhaps the most important feature of a native application is the instant start and display of the application shell — ordinary web applications, as you know, do not have such an ability — depending on the user's location and the quality of the mobile Internet, the first page of the application may load for several seconds, displaying a white screen.

Our application is a Server Side Rendering application for React. For its work, it requires loading a certain number of scripts, styles, and images. Resources are specified attributes that assume their long-term storage in the user's browser cache (for a later faster start). But unfortunately, a modern user per hour views so many resources and loads so much content that simply does not leave a chance to remain in the cache of our resources until the next user visits our application. Therefore, our server is forced to give away dozens of resources over and over again with each connection, loading the communication channels, devouring the server's processor time and slowing down the display of our application to the user.
(today, technology companies are conducting research and development on storing the cache not in a common space, but for each domain separately, which in the future may solve the problem of cache flushing)

To solve this problem radically today allows caching service worker, which reliably saves resources in the browser and thus turns our application into a PWA, allowing our application to start almost instantly and display its original content.

A couple of years ago, we wrote such a service worker, which contained about 200 lines, performed its functions and, in principle, satisfied us. When you first visit the site, it stores all the necessary resources in the cache, as well as a special page that serves as an application shell and is loaded from the cache every time a user opens our site, implementing the App Shell application model.

Before that, I looked at the Workbox of earlier versions several times and tried it on for our project, but each time something did not work out and probably for the best.

Actually, the report of Maxim Salnikov — “Automating the service worker with Workbox 6”-pushed me to the final transition to Workbox. Maxim, the report showed the code for the new version of Workbox and said a few good thoughts about what the code of the service worker, written by hand in many aspects the bad:

- specifications service workers subject to change
- implementation of service workers in the different browsers can differ
- until the end there is no certainty that the code written is true
- build automation service worker you need to do it yourself
- code of the service worker is poorly structured and not designed for future changes
- it is cumbersome and poorly read
- it, as a rule, not declarative
- and over time, the code becomes obsolete and needs to constantly monitor, and it's usually not enough time

And many other bad things may be in self written code for the service worker. Why not shift the entire burden of responsibility for writing and maintaining the code to those who do it professionally and use the ready-made code in their application?

In general, I plunged into the study of Workbox and within 2 days our 200-line code turned into a few lines!

C o d e  h e r e …

That's the whole code of our service worker!

At the start, it caches all the resources generated by our bundler in the cache — self.__WB _ MANIFEST contains an array of resource urls. It then caches and logs app-shell.html as a resource that will be loaded instead of pages from the server. The last 2 instructions put our service worker in the active state of page management immediately after its loading and the end of resource caching.

In order to inject self.__WB _ MANIFEST into the code of the service worker, you need to use the appropriate plugin for your bundler — this is done in a couple of lines (see the documentation).
At the first page load, Workbox downloads all the resources necessary for caching from the server, despite the fact that they may have already been downloaded and are in the browser cache.

When changing resources on the server - Workbox loads and updates only the changed ones in the cache.

I will tell you about a small emergency with our application to describe the problem of cache integrity and how it is solved in Workbox.
Once a user came to our technical support with a strange bug — the application did not load. We puzzled over the problem for a long time, until we decided to investigate the cache state of our application in its browser — it turned out that there were several resources missing. Either the user himself deleted them, or some extension did it, but the application remained not working and the user's efforts could not be restored.

We took care of this problem and wrote code that looked into the cache when navigating, and if it did not find a resource from the manifest there, it went to the server for it, gave it to the browser and cached it again. This solved the problem of cache integrity when it was corrupted.

When switching to Workbox, it turned out that if you delete the entire cache, Workbox will pretend that everything is fine and just go for all the resources silently to the server, without putting them back in the cache, reducing to 0 all the efforts that were made when writing the service worker to avoid such a situation.

I described the problem to the Workbox developers, and although they did not agree with me that to recover the cache is still suggested a way to fix this situation — to the beginning of the code to add the description of the plugin that will do the job for loading and saving to cache resources from the manifest, in case of their absence in the cache.


C o d e  h e r e …


By adding this code to the beginning of our service worker, we will ensure the integrity of the cache, ensuring that if the loaded resource from the manifest is not in the cache, we will put it there again the next time it is accessed.

This plugin restores only those lost resources in the cache that were accessed. The plugin can be modified so that it checks all the resources at once and restores all the missing ones at once.

Actually, this is the whole story of translating the service worker to Workbox.

Thank you to Yandex for the conference and to Max for the useful report! :)
